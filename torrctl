#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import os
import re
import sys

import PTN as ptn
import requests
from urllib.parse import quote

for func_name in ("get", "post"):
    orig_func = getattr(requests, func_name)
    def req_wrapper(*args, **kwargs):
        try:
            return orig_func(*args, **kwargs)
        except (
            requests.exceptions.MissingSchema,
            requests.exceptions.ConnectionError,
            requests.exceptions.ConnectTimeout,
            requests.exceptions.Timeout,
            requests.exceptions.RequestException,
            # ...
        ) as ex:
            print(ex.__doc__)
            sys.exit(1)
    setattr(requests, func_name, req_wrapper)

TORRSERVER_URL = "http://127.0.0.1:8090"
HEADERS = {
    "User-Agent": "Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; fr-fr) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5",
    "Content-Type": "application/json"
}

CATEGORIES = ("movies", "series", "music", "other")

MAGNET_URL_RE = re.compile(r'^magnet:\?xt=urn:btih:[0-9A-Fa-f]{40}(?:&dn=[^&]*|&tr=[^&]*)*')
BTIH_RE = re.compile(r'^[0-9a-fA-F]{40}$')

LS_HEADER_MAP = {
    "title": "Title",
    "torrent_size": "Size",
    "hash": "Infohash",
    "category": "Category",
}

INFO_HEADER_MAP = {
    "id": "ID",
    "path": "Path",
    "length": "Size",
    "timestamp": "Timestamp", # TODO: figure out what it means
}

if url := os.environ.get("TORRSERVER_URL"):
    # TODO: validate URL, must be http|https:// and host, without paths and query
    TORRSERVER_URL = url

if (user := os.environ.get("TORRSERVER_USER")) and (password := os.environ.get("TORRSERVER_PASSWORD")):
    from base64 import b64encode
    HEADERS["Authorization"] = f"Basic ${b64encode((user + password).encode("utf-8"))}"

def parse_hash(args: argparse.Namespace) -> str:
    hash = args.hash

    if not BTIH_RE.match(hash):
        print("Invalid infohash!")
        sys.exit(1)

    return hash

def parse_id(args: argparse.Namespace) -> int:
    id = args.id
    if id <= 0:
        print("Invalid ID!")
        sys.exit(1)
    return id

def parse_fields(fields_comma: str, field_map: dict) -> list[str]:
    fields = fields_comma.split(",")
    for field in fields:
        if field not in field_map:
            print(f"Invalid field: {field}")
            sys.exit(1)
    return fields

def request_torrent_list() -> list[dict]:
    req = requests.post(f"{TORRSERVER_URL}/torrents", headers=HEADERS, json={"action": "list"})
    return req.json()

def request_torrent_info(hash: str) -> dict:
    req = requests.post(f"{TORRSERVER_URL}/cache", json={"action": "get", "hash": hash})
    if req.status_code in (404, 500):
        print("Torrent with this infohash doesn't exist!")
        sys.exit(1)

    torrent_info = req.json()
    if not torrent_info:
        print("Something went wrong! Try again!")
        sys.exit(1)

    return torrent_info

def update_paddings(paddings: dict[str, int], data: dict[str, str]) -> None:
    for key in data:
        length = len(str(data[key]))
        try:
            if length > paddings[key]:
                paddings[key] = length
        except KeyError:
            pass

def convert_size(size: float) -> str:
    for measure in ("", "B", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"):
        if size <= 100:
            return f"{size:.2f} {measure}"
        size /= 1024
    return "âˆž"

def shorten_title(title: str) -> str:
    meta = ptn.parse(title)
    result = meta["title"]
    if meta.get("year"): result += f" ({meta["year"]})"
    if meta.get("resolution"): result += f" [{meta["resolution"]}]"
    return result

def display_data(
    entries: list[dict], paddings: dict[str, int], data_keys: list[str], field_map: dict,
    plain: bool = False, bold_key: str | None = None, bold_values: list[str] | None = None
) -> None:
    if not plain:
        print("\033[1m", end="")
        print(
            "  ".join(str(field_map[key]).ljust(paddings[key]) for key in data_keys)
        )
        print("\033[0m", end="")

    for entry in entries:
        if viewed := bold_values and str(entry[bold_key]) in bold_values:
            print("\033[1m", end="")
        print(
            "  ".join(str(entry[key]).ljust(paddings[key]) for key in data_keys)
        )
        if viewed:
            print("\033[0m", end="")

''' NOTE: if torrent with a specified hash doesn't exist, TorrServer will respond with 500 error.
    If torrent's series ID doesn't exist, TorrServer will respond with 200 code, but empty body.
    This script doesn't check existence of this entry. App into which you insert the link has to handle this. '''

def get_playlist_link(hash: str, from_latest: bool = False) -> str:
    return f"{TORRSERVER_URL}/playlist?hash={hash}{"&fromlast=true" if from_latest else ""}"

def get_stream_link(hash: str, id: int) -> str:
    return f"{TORRSERVER_URL}/play/{hash}/{id}"

parser = argparse.ArgumentParser(
    prog="torrctl",
    description="CLI for TorrServer",
    add_help=True,
    epilog='''
environment variables:
    TORRSERVER_URL - URL of TorrServer instance
        Default value - http://127.0.0.1:8090
    TORRSERVER_USER - TorrServer username
    TORRSERVER_PASSWORD - TorrServer password
''',
    formatter_class=argparse.RawDescriptionHelpFormatter
)
subparsers = parser.add_subparsers(dest="action", required=True)

list_parser = subparsers.add_parser("list", aliases=["ls"], help="List available torrents")
list_parser.add_argument("--fields", "-f", type=str,
    help=f"Columns the output table has to include, separated by comma (choose from {",".join(list(LS_HEADER_MAP.keys()))})"
)
list_parser.add_argument("--plain", "-p", action="store_true", help="Plain output (do not print table header)")
# TODO: add filter by --category

add_parser = subparsers.add_parser("add", help="Add magnet link or .torrent file")
add_parser.add_argument("torrent", type=str, help="Magnet link or .torrent file path")
add_parser.add_argument("--url", "-u", required=False, action="store_true", help="Print URL for HLS stream (e.g. for MPV)")
add_parser.add_argument("--latest", "-l", required=False, action="store_true", help="Compose .m3u playlist from last played file")
add_parser.add_argument("--category", "-c", required=False, help="Category of torrent (movies, series, music, other)")

remove_parser = subparsers.add_parser("remove", aliases=["rem", "rm"], help="Remove torrent by its ID")
remove_parser.add_argument("hash", type=str, help="Infohash of entry")

info_parser = subparsers.add_parser("info", aliases=["i"], help="Show info about entry ID")
info_parser.add_argument("hash", type=str, help="Infohash of entry")
info_parser.add_argument("--fields", "-f", type=str,
    help=f"Columns the output table has to include, separated by comma (choose from {",".join(list(INFO_HEADER_MAP.keys()))})"
)
info_parser.add_argument("--plain", "-p", action="store_true", help="Plain output (do not print table header and footer)")

playlist_parser = subparsers.add_parser("playlist", help="Print .m3u playlist URL for torrent entry")
playlist_parser.add_argument("hash", type=str, help="Infohash of entry")
playlist_parser.add_argument("--latest", "-l", action="store_true", help="Compose .m3u playlist from last played file")

play_parser = subparsers.add_parser("play", help="Print link for HLS stream of individual series of torrent entry")
play_parser.add_argument("hash", type=str, help="Infohash of entry")
play_parser.add_argument("id", type=int, help="Series number")

load_parser = subparsers.add_parser("load", help="Preload torrent's file into TorrServer's cache")
load_parser.add_argument("hash", type=str, help="Infohash of entry")
load_parser.add_argument("id", type=int, help="Series number")

unload_parser = subparsers.add_parser("unload", help="Unload torrent from TorrServer's cache")
unload_parser.add_argument("hash", type=str, help="Infohash of entry")

# TODO: /ffp

magnet_parser = subparsers.add_parser("magnet", help="Print magnet link for torrent with infohash")
magnet_parser.add_argument("hash", type=str, help="Infohash of entry")

stat_parser = subparsers.add_parser("stat", help="Print TorrServer's stats")

args = parser.parse_args()


if args.action in ("list", "ls"):
    if not args.fields:
        LIST_COLS = ["hash", "title", "torrent_size"]
    else:
        LIST_COLS = parse_fields(args.fields, LS_HEADER_MAP)

    paddings = {key: 0 for key in LIST_COLS}
    torrents = request_torrent_list()

    for i in range (len(torrents)):
        torrents[i]["title"] = shorten_title(torrents[i]["title"])
        torrents[i]["torrent_size"] = convert_size(torrents[i]["torrent_size"])
        update_paddings(paddings, torrents[i])
    display_data(torrents, paddings, LIST_COLS, LS_HEADER_MAP, bool(args.plain))

elif args.action == "add":
    # NOTE: handling the case with already existing torrent is not needed. TorrServer will just respond with 200 code and do nothing.
    link = args.torrent

    if args.category:
        if args.category not in CATEGORIES:
            print("Invalid category!")
            sys.exit(1)

    if MAGNET_URL_RE.match(link):
        body = {
            "action": "add",
            "save_to_db": True,
            "link": link
        }
        body["category"] = args.category
        req = requests.post(f"{TORRSERVER_URL}/torrents", json=body)
    elif os.path.exists(link):
        with open(link, "rb") as fd:
            # TODO: pass torrent category in this request
            req = requests.post(f"{TORRSERVER_URL}/torrent/upload", files={"file": fd})
    else:
        print("You must specify either magnet link or path to your .torrent file!")
        sys.exit(1)

    if req.status_code == 200:
        new_torrent_info = req.json()
        if args.url:
            print(get_playlist_link(new_torrent_info["hash"], True if args.latest else False))
        else:
            print(f"Added new torrent: {new_torrent_info["name"]}")
    else:
        if req.status_code == 401:
            print("You are not authorized!")
        else:
            print(f"Unknown error: {req.status_code}")
        sys.exit(1)

# TODO: add option to hide secondary files (e.g. subtitles for videos)
elif args.action in ("info", "i"):
    if not args.fields:
        INFO_COLS = ["id", "path", "length"]
    else:
        INFO_COLS = parse_fields(args.fields, INFO_HEADER_MAP)
    paddings = {key: 0 for key in INFO_COLS}

    hash = parse_hash(args)
    torrent_info = request_torrent_info(hash)

    if not args.plain:
        if category := torrent_info["Torrent"]["category"]:
            print(f"\033[1mCategory\033[0m: {category}")

    torrent_entries = torrent_info["Torrent"]["file_stats"]

    req = requests.post(f"{TORRSERVER_URL}/viewed", json={"action": "list", "hash": hash})
    viewed_entries = list(map(lambda entry: str(entry["file_index"]), req.json()))

    for i in range(len(torrent_entries)):
        torrent_entries[i]["length"] = convert_size(torrent_entries[i]["length"])
        update_paddings(paddings, torrent_entries[i])
    display_data(
        torrent_entries, paddings,
        INFO_COLS, INFO_HEADER_MAP, bool(args.plain),
        "id", viewed_entries
    )

    if not args.plain:
        print(f"\033[1mSeeds, peers\033[0m: {torrent_info["Torrent"]["active_peers"]} / {torrent_info["Torrent"]["total_peers"]}")

elif args.action == "playlist":
    hash = parse_hash(args)
    print(get_playlist_link(hash, True if args.latest else False))

elif args.action == "play":
    hash = parse_hash(args)
    id = parse_id(args)
    print(get_stream_link(hash, id))

elif args.action == "load":
    hash = parse_hash(args)
    id = parse_id(args)
    req = requests.get(f"{TORRSERVER_URL}/stream", params={"link": hash, "index": id, "preload": ""})
    print(f"Preloading {hash}")

elif args.action == "unload":
    hash = parse_hash(args)
    req = requests.post(f"{TORRSERVER_URL}/torrents", params={"action": "drop", "hash": hash})
    print(f"Unloading {hash}")

elif args.action == "magnet":
    hash = parse_hash(args)
    torrent_info = request_torrent_info(hash)
    print(f"magnet:?xt=urn:btih:{hash}&dn={quote(torrent_info["Torrent"]["name"])}")

elif args.action in ("remove", "rem", "rm"):
    hash = parse_hash(args)
    # NOTE: TorrServer will respond 200 even if torrent with a specified hash doesn't exist.
    req = requests.post(f"{TORRSERVER_URL}/torrents", json={"action": "rem", "hash": hash})
    print(f"Removed {hash}")

elif args.action == "stat":
    HEADERS["Accept"] = "text/plain"

    # For unknown reason, if the monkey patch for requests GET method is not reset, TorrServer will always respond with 404 code.
    import importlib
    importlib.reload(requests)
    setattr(requests, "get", getattr(requests, "get"))

    req = requests.get(f"{TORRSERVER_URL}/stat", headers=HEADERS)
    print(req.text)

else:
    parser.print_help()
    sys.exit(1)
