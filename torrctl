#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import os
import re
import sys

import requests

for func_name in ("get", "post"):
    orig_func = getattr(requests, func_name)
    def req_wrapper(*args, **kwargs):
        try:
            return orig_func(*args, **kwargs)
        except (
            requests.exceptions.MissingSchema,
            requests.exceptions.ConnectionError,
            requests.exceptions.ConnectTimeout,
            requests.exceptions.Timeout,
            requests.exceptions.RequestException,
            # ...
        ) as ex:
            print(ex.__doc__)
            sys.exit(1)
    setattr(requests, func_name, req_wrapper)

TORRSERVER_URL = "http://127.0.0.1:8090"
HEADERS = {
    "User-Agent": "Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; fr-fr) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5",
    "Content-Type": "application/json"
}

CATEGORIES = ("movies", "series", "music", "other")

MAGNET_URL_RE = re.compile(r'^magnet:\?xt=urn:btih:[0-9A-Fa-f]{40}(?:&dn=[^&]*|&tr=[^&]*)*')
BTIH_RE = re.compile(r'^[0-9a-fA-F]{40}$')

if url := os.environ.get("TORRSERVER_URL"):
    TORRSERVER_URL = url

if (user := os.environ.get("TORRSERVER_USER")) and (password := os.environ.get("TORRSERVER_PASSWORD")):
    from base64 import b64encode
    HEADERS["Authorization"] = f"Basic ${b64encode((user + password).encode("utf-8"))}"

def parse_hash(args: argparse.Namespace) -> str:
    hash = args.hash

    if not BTIH_RE.match(hash):
        print("Invalid infohash!")
        sys.exit(1)

    return hash

def request_torrent_list():
    req = requests.post(f"{TORRSERVER_URL}/torrents", headers=HEADERS, json={"action": "list"})
    return req.json()

def request_torrent_info(hash: str) -> dict:
    req = requests.post(f"{TORRSERVER_URL}/cache", json={"action": "get", "hash": hash})
    if req.status_code in (404, 500):
        print("Torrent with this infohash doesn't exist!")
        sys.exit(1)

    torrent_info = req.json()
    if not torrent_info:
        print("Something went wrong! Try again!")
        sys.exit(1)

    return torrent_info

def update_paddings(paddings: dict, data: dict) -> None:
    for key in data:
        length = len(str(data[key]))
        if length > paddings[key]:
            paddings[key] = length

def convert_size(size: float) -> str:
    for measure in ("", "B", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"):
        if size <= 100:
            return f"{size:.2f} {measure}"
        size /= 1024
    return "âˆž"

def cut_torrent_keys(torrent: dict, keys: list[str]) -> dict:
    result = {
        key: torrent[key] for key in torrent if key in keys
    }
    for key in ("torrent_size", "length"):
        try:
            result[key] = convert_size(result[key])
        except KeyError:
            pass
    return result


def display_data(
    entries: list, paddings: dict, data_keys: list[str],
    bold_key: str | None = None, bold_values: list[str] | None = None
) -> None:
    print("\033[1m", end="")
    print(
        "  ".join(str(COL_HEADER_MAP[key]).ljust(paddings[key]) for key in data_keys)
    )
    print("\033[0m", end="")

    for entry in entries:
        if viewed := bold_values and str(entry[bold_key]) in bold_values:
            print("\033[1m", end="")
        print(
            "  ".join(str(entry[key]).ljust(paddings[key]) for key in data_keys)
        )
        if viewed:
            print("\033[0m", end="")

''' NOTE: if torrent with a specified hash doesn't exist, TorrServer will respond with 500 error.
    If torrent's series ID doesn't exist, TorrServer will respond with 200 code, but empty body.
    This script doesn't check existence of this entry. App into which you insert the link has to handle this. '''

def get_playlist_link(hash: str, from_latest: bool = False) -> str:
    return f"{TORRSERVER_URL}/playlist?hash={hash}{"&fromlast=true" if from_latest else ""}"

def get_stream_link(hash: str, id: int) -> str:
    return f"{TORRSERVER_URL}/play/{hash}/{id}"

# TODO: add env variable into help msg
parser = argparse.ArgumentParser(
    prog="torrctl",
    description="CLI for TorrServer",
    add_help=True,
    epilog='''
environment variables:
    TORRSERVER_URL - URL of TorrServer instance
        Default value - http://127.0.0.1:8090
    TORRSERVER_USER - TorrServer username
    TORRSERVER_PASSWORD - TorrServer password
''',
    formatter_class=argparse.RawDescriptionHelpFormatter
)
subparsers = parser.add_subparsers(dest="action", required=True)

list_parser = subparsers.add_parser("list", aliases=["ls"], help="List available torrents")
# TODO: add filter by --category

add_parser = subparsers.add_parser("add", help="Add magnet link or .torrent file")
add_parser.add_argument("torrent", type=str, help="Magnet link or .torrent file path")
add_parser.add_argument("--url", "-u", action="store_true", help="Print URL for HLS stream (e.g. for MPV)")
add_parser.add_argument("--latest", "-l", action="store_true", help="Compose .m3u playlist from last played file")
add_parser.add_argument("--category", "-c", required=False, help="Category of torrent (movies, series, music, other)")

remove_parser = subparsers.add_parser("remove", aliases=["rem", "rm"], help="Remove torrent by its ID")
remove_parser.add_argument("hash", type=str, help="Infohash of entry")

info_parser = subparsers.add_parser("info", aliases=["i"], help="Show info about entry ID")
info_parser.add_argument("hash", type=str, help="Infohash of entry")

playlist_parser = subparsers.add_parser("playlist", help="Print .m3u playlist URL for torrent entry")
playlist_parser.add_argument("hash", type=str, help="Infohash of entry")
playlist_parser.add_argument("--latest", "-l", action="store_true", help="Compose .m3u playlist from last played file")

play_parser = subparsers.add_parser("play", help="Print link for HLS stream of individual series of torrent entry")
play_parser.add_argument("hash", type=str, help="Infohash of entry")
play_parser.add_argument("id", type=int, help="Series number")

magnet_parser = subparsers.add_parser("magnet", help="Print magnet link for torrent with infohash")
magnet_parser.add_argument("hash", type=str, help="Infohash of entry")

stat_parser = subparsers.add_parser("stat", help="Print TorrServer's stats")

args = parser.parse_args()

COL_HEADER_MAP = {
    "title": "Title",
    "torrent_size": "Size",
    "hash": "Infohash",
    "category": "Category",
    "id": "ID",
    "path": "Filename",
    "length": "Size",
}

if args.action in ("list", "ls"):
    # NOTE: response titles may differ from entries in TorrServer's web UI. It somehow converts long torrent names into short ones. This script should do the same.
    LIST_COLS = ["hash", "title", "torrent_size"]
    paddings = {key: 0 for key in LIST_COLS}
    torrents = request_torrent_list()
    torrents = [cut_torrent_keys(torrent, LIST_COLS) for i, torrent in enumerate(torrents)]

    for torrent in torrents:
        update_paddings(paddings, torrent)
    display_data(torrents, paddings, LIST_COLS)
elif args.action == "add":
    # NOTE: handling the case with already existing torrent is not needed. TorrServer will just respond with 200 code and do nothing.
    link = args.torrent

    if args.category:
        if args.category not in CATEGORIES:
            print("Invalid category!")
            sys.exit(1)

    if MAGNET_URL_RE.match(link):
        body = {
            "action": "add",
            "save_to_db": True,
            "link": link
        }
        body["category"] = args.category
        req = requests.post(f"{TORRSERVER_URL}/torrents", json=body)
    elif os.path.exists(link):
        with open(link, "rb") as fd:
            # TODO: pass torrent category in this request
            req = requests.post(f"{TORRSERVER_URL}/upload", files={"file": fd})
    else:
        print("You must specify either magnet link or path to your .torrent file!")
        sys.exit(1)

    if req.status_code == 200:
        new_torrent_info = req.json()
        if args.url:
            print(get_playlist_link(new_torrent_info["hash"], True if args.latest else False))
        else:
            print(f"Added new torrent: {new_torrent_info["name"]}")
    else:
        if req.status_code == 401:
            print("You are not authorized!")
        else:
            print(f"Unknown error: {req.status_code}")
        sys.exit(1)

elif args.action == "info":
    INFO_COLS = ["id", "path", "length"]
    paddings = {key: 0 for key in INFO_COLS}

    hash = parse_hash(args)
    torrent_info = request_torrent_info(hash)

    if category := torrent_info["Torrent"]["category"]:
        print(f"\033[1mCategory\033[0m: {category}")

    torrent_entries = torrent_info["Torrent"]["file_stats"]
    torrent_entries = [cut_torrent_keys(entry, INFO_COLS) for entry in torrent_entries]

    req = requests.post(f"{TORRSERVER_URL}/viewed", json={"action": "list", "hash": hash})
    viewed_entries = list(map(lambda entry: str(entry["file_index"]), req.json()))

    for entry in torrent_entries:
        update_paddings(paddings, entry)
    display_data(torrent_entries, paddings, INFO_COLS, "id", viewed_entries)

    print(f"\033[1mSeeds, peers\033[0m: {torrent_info["Torrent"]["active_peers"]} / {torrent_info["Torrent"]["total_peers"]}")

elif args.action == "playlist":
    hash = parse_hash(args)
    print(get_playlist_link(hash, True if args.latest else False))

elif args.action == "play":
    hash = parse_hash(args)
    id = args.id
    if id <= 0:
        print("Invalid ID!")
        sys.exit(1)
    print(get_stream_link(hash, id))

elif args.action == "magnet":
    hash = parse_hash(args)
    torrent_info = request_torrent_info(hash)
    print(f"magnet?xt=urn:btih:{hash}&dn={torrent_info["Torrent"]["name"]}")

elif args.action in ("remove", "rem", "rm"):
    hash = parse_hash(args)
    # NOTE: TorrServer will respond 200 even if torrent with a specified hash doesn't exist.
    req = requests.post(f"{TORRSERVER_URL}/torrents", json={"action": "rem", "hash": hash})
    print(f"Removed {hash}")

elif args.action == "stat":
    HEADERS["Accept"] = "text/plain"

    # For unknown reason, if the monkey patch for requests GET method is not reset, TorrServer will always respond with 404 code.
    import importlib
    importlib.reload(requests)
    setattr(requests, "get", getattr(requests, "get"))

    req = requests.get(f"{TORRSERVER_URL}/stat", headers=HEADERS)
    print(req.text)

else:
    parser.print_help()
    sys.exit(1)
